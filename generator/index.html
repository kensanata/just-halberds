<!DOCTYPE html>
<html lang="en"> <!-- Change this for hyphenation in other languages! -->
<head>
<meta charset="utf-8">
<title>Generator</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />

<style>
@media screen {
    body {
        background: #000;
        color: #fff;
    }
    #noprintheader hr {
        background: green;
        border: 0;
        height: 1px;
        margin: 0.25em 0em 1.5em -10em;
    }
}
@media print {
    body {
        background: #fff;
        color: #000;
    }
    #noprintheader hr {
        display: none;
    }
    #noprintheader {
        display: none;
    }
}
body {
    background: #000;
    color: #fff;
    font-family: "Dejavu Sans Mono", Inconsolata, Monaco, Courier, monospace;
    font-size: 12pt;
    margin: 1em;
    margin-left: clamp(1ex, 5%, 4em);
    hyphens: auto;
}
#target {
    white-space: pre-wrap;
    max-width: 45em;
}
#links {
    padding: 0;
    font-size: smaller;
}
#links li {
    display: inline;
}
table {
    border-collapse: collapse;
}
td {
    padding: 0.5ex;
    border: 1px solid grey;
}
td:first-child {
    text-align: center;
}
a {
    color: chartreuse;
    text-decoration: none;
}
a:visited {
    color: green;
}
a:hover {
    text-decoration: underline;
}
</style>

<script>
function parse(data) {
  // This is the return of parse().
  let h = {};

  // Save the data so that h can be reused in multiple calls to generate().
  h.tables = transform(data);

  // Generate text. This function is accessible from the outside.
  h.generate = function(start) {
    h.names = {}; // reset
    return pick(start);
  };

  // Read data and parse comments, table names and weighted rows.
  function transform(data) {
    let table = {};
    let rows;
    data.split("\n").forEach(row => {
      row.replace(/#.*/, ""); // Comments
      let m;
      if (row.startsWith(";")) { rows = []; table[row.substring(1)] = rows; }
      else if ((m = row.match(/^(\d+),(.*)/))) { rows.push([m[2], Number(m[1])]); }
    });
    return table;
  }

  // Save the results of the last call
  h.results = {};

  // The list of names ensures that generated names are unique
  h.names;

  // Do replacements when you return
  h.replacements = [];

  // Recursively pick items from tables and process the string
  function pick(table, level) {
    if (level == undefined) {
      level = 1;
      h.results = {};
    } else if (level > 20) {
      console.log(`Recursion deeper than 20 for ${table}`);
      return "…";
    }
    // [@b++] returns the key with the highest value in map b
    if (table.startsWith('@++')) {
       let value = h.results[table.substring(3)];
       return shuffle(Object.keys(value)).reduce((ac, cur) => value[ac] > value[cur] ? ac : cur, 0);
    }
    // [@b] take the existing value for b
    if (table.startsWith('@')) {
       let value = h.results[table.substring(1)];
       if (value === undefined) { console.log("No stored value for " + table); return "…"; }
       if (Array.isArray(value)) return value.join(", ");
       if (value === Object(value)) return Object.keys(value).sort().map(key => key + "-" + value[key]).join(", ");
       return value;
    }
    // otherwise, pick an appropriate item
    let text = weighted_pick(table);
    // look for search and replace suffixes like /a/b/ (this only
    // works for levels > 1)
    const m = text.match(/\/([^\/]+)\/([^\/]*)\/$/);
    // Short by the search & replace pattern, if any.
    if (m) {
      text = text.substring(0, text.length - m[0].length);
      h.replacements.push(m);
    }
    while (true) {
      let e = false;
      // [2d6] rolls dice
      text = text.replaceAll(/\[(\d+)d(\d+)(?:([+-]\d+))?\]/g,
                             (m, n, d, p) => { e = true; return roll(Number(n), Number(d), p ? Number(p) : 0); });
      if (e) continue;
      // [a++@b] increments value of key a in map b
      text = text.replaceAll(/\[([^\[\]]+)\+\+@([^\[\]]+)\]/g,
                             (m, a, b) => { e = true;
                                            h.results[b] ||= {};
                                            h.results[b][a] ||= 0;
                                            h.results[b][a]++;
                                            return ''; });
      if (e) continue;
      // [a@@b] appends a to list b
      text = text.replaceAll(/\[([^\[\]]+)@@([^\[\]]+)\]/g,
                             (m, a, b) => { e = true;
                                            h.results[b] ||= [];
                                            h.results[b].push(a);
                                            return ''; });
      if (e) continue;
      // [a@b] saves a as b
      text = text.replaceAll(/\[([^\[\]]+)@([^\[\]]+)\]/g,
                             (m, a, b) => { e = true; h.results[b] = a; return ''; });
      if (e) continue;
      // [a|b] choose a or b
      text = text.replaceAll(/\[([^\[\]]+\|[^\[\]]+)\]/g,
                             (m, w) => { e = true; return one(w.split('|')); });
      if (e) continue;
      // [x?a:b] choose a or b depending on whether x is true or false
      text = text.replaceAll(/\[([^\[\]]+)\?([^\[\]]*):([^\[\]]*)\]/g,
                             (m, x, a, b) => { e = true; return eval(x) ? a : b; });
      if (e) continue;
      // [a] pick an entry from table 'a' – but do this just once and
      // then restart the process, otherwise something like
      // "[[a]@b][c]" will call table 'c' before setting 'b'.
      text = text.replace(/\[([^@\[\]]+)\]/,
                          (m, a) => { e = true; return pick(a, level + 1); });
      if (e) {
        h.replacements.forEach((m) => text = text.replace(new RegExp(m[1], m[3]), m[2]));
        continue;
      }
      // [@b] use variable b (after all the [a] have been replaced)
      text = text.replaceAll(/\[(@[^\[\]]+)\]/g,
                             (m, b) => { e = true; return pick(b, level + 1); });
      if (e) continue;
      break;
    }

    // Retry duplicates
    if (table.endsWith(" name")) {
      let key = `${table}: ${text}`;
      if (h.names[key]) {
        // console.log(`Seen ${key} before`);
        text = pick(table, level + 1);
      } else {
        // console.log(`Seen ${key} for the first time`);
        h.names[key] = true;
      }
    }

    // Save
    h.results[table] = text;

    if (level === 1) {
      // emphasis
      text = text.replaceAll(/\*\*(.*?)\*\*/g, (m, a) => { return `<strong>${a}</strong>` });
      text = text.replaceAll(/\*(.*?)\*/g, (m, a) => { return `<emph>${a}</emph>` });
      text = text.replaceAll("¶", "<p>");
    }
    return text;
  }

// Pick an item from the table,
  function weighted_pick(table) {
    const t = h.tables[table];
    if (!t) { console.log(`There is no table ${table}`); return "…"; }
    const total = t.reduce((n, x) => n + x[1], 0);
    // start with 1
    const n = Math.floor(Math.random() * total) + 1;
    let i = 0;
    for (const z of t) {
      i += z[1];
      if (i >= n) return z[0];
    }
    console.log(`The table ${table} has no result for ${n}`);
    return "…";
  }

  function shuffle(a) {
    for(let i = a.length - 1; i > 0; i--){
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  // Return a random element from arr.
  function one(arr) {
    return arr[Math.floor(Math.random() * arr.length)];
  }

  // Roll dice.
  function roll(num, sides = 6, plus = 0) {
    let total = 0;
    for (var i = 0; i < num; i++) {
      total += Math.floor(Math.random() * sides + 1);
    }
    return total + plus;
  }

  // To do anything, call generate().
  return h;
}

function linked(data) {
  data = data.replaceAll(/^;(.*)/mg,
                         (m, t) => {
                           return ";<strong id=\"" + t.replaceAll(" ", "-").toLowerCase() + "\">"
                             + t + "</strong>" });
  data = data.replaceAll(/\[([^@\[\]\|]+)\]/g,
                         (m, t) => {
                           if (m.match(/^\[\d+d\d+(?:\+\d+)?\]$/)) return m;
                           if (m.match(/\?.*:/)) return m;
                           return "[<a href=\"#" + t.replaceAll(" ", "-").toLowerCase() + "\">"
                             + t + "</a>]" });
  data = data.replaceAll(/\*\*(.*?)\*\*/g, (m, a) => { return `<strong>${a}</strong>` });
  data = data.replaceAll(/\*(.*?)\*/g, (m, a) => { return `<emph>${a}</emph>` });
  data = data.replaceAll("¶", "<p>");
  return data;
}

function paper(data) {
  let html = "";
  let n;
  data.split("\n").forEach(row => {
    row.replace(/#.*/, ""); // Comments
    let m;
    if (row.startsWith(";")) {
      if (html) html += "</table>\n";
      html += "<table>\n";
      html += `<tr><th>Roll</th><th>${row.substring(1)}</th></tr>\n`;
      n = 1;
    } else if ((m = row.match(/^(\d+),(.*)/))) {
      let from = n;
      let to = n + (Number(m[1]) - 1);
      n = to + 1;
      html += `<tr><td>${from == to ? from : from + "-" + to}</td><td>${m[2]}</td></tr>\n`;
    }
  });
  return html;
}

function generate(f) {
  const data = document.getElementById('data').textContent;
  document.getElementById('target').innerHTML = f(data);
}

</script>
</head>
<body>

<h1 id="noprintheader">Generator</h1>
<div id="noprintheader">
  <button type="button" onclick="generate((data) => parse(data).generate('start'))">Generate</button>
  <button type="button" onclick="generate((data) => linked(data))">Show tables</button>
  <button type="button" onclick="generate((data) => paper(data))">Printable tables</button>
  <ul id="links">
    <li><a href="https://alexschroeder.ch/pdfs/Knives.pdf">Knives</a>
    <li><a href="https://alexschroeder.ch/wiki/Contact">Alex Schröder</a>
    <li><a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0 1.0</a>
  </ul>
  <hr>
</div>

<div id="target">This is a stand-alone generator. You can save the HTML file locally and
it will continue to work. Feel free to use examine, change and distribute
it elsewhere. No strings attached. It is dedicated to the public domain.

You can replace all the tables in this file with your own and make your
own generators! Please do.
</div>

<pre id="data" style="display: none">
# Data

# As this data needs to be valid HTML, you need to replace < & > in
# the tables with &lt; &amp; &gt; (less than, ampersand, greater
# than).

# '#' begins a comment
# '*a*' renders 'a' in italics (emphasis)
# '**a**' renders 'a' in bold (strong emphasis)
# ¶ results in a paragraph break (a shorthand for &lt;p&gt;)
# ';' begins a table, followed by a name, no space
# A number and a comma begin a weighted entry for the current table
# /re/to/ at the end replaces regular expression "re" with "to"
# '[2d6]' or '[1d6+3]' are replaced by dice rolls
# '[a]' gets replaced with a lookup of table 'a'
# '[a|b]' gets replaced with 'a' or 'b'
# '[x?a:b]' evaluates x as JavaScript and if "true" it is replaced with 'a' else with 'b'
# '[a@b]' stores 'a' as variable 'b' (usage example: [[table]@b])
# '[a@@b]' does a lookup of table 'a' and appends it to the list 'b'
# '[a++@b]' increments the key 'a' by one for the map 'b'
# '[@b]' uses the value of variable 'b' (don't use [a@b], [[a]@b] and [@b] on the same line: the order can be confusing!)
# If b is a list, return a comma-separated list.
# If b is a map, return a sorted, comma-separated list of key-value pairs
# '[@++b]' gets replaced by the key with the highest value in map b

;start
1,[initial setup]¶[map]

;initial setup
1,The land is in turmoil. Old [name] died and now their oldest children are collecting old debts and calling in favours. How are you going to align yourself: [[name]@side a][@side a] or [[name]@side b][@side b]? Or will you take to the woods and find [[name]@side c][@side c]?
1,There is unrest. [[name]@side a][@side a] rules the land but the harvest has been bad and raiders are plaguing the peasants. [[name]@side b][@side b] returned from a pilgrimage to foreign lands and some are whispering that they will right all wrongs. And then of course there is rable rouser [[name]@side c][@side c], always ready to exploit a weakness.

# The map always has the same structure, for the moment.
# - Two towns by the lake
# - The first town connects to a main valley with three villages.
# - The second town connects to a main valley with two villages.
# - All but the last village of the main valley connect to a secondary valley.
# - These secondary valleys have exactly one village.
# - In each of these remote villages of secondary valleys stands a wizard tower.
# - At the end of every valley there is a ruin.
# - Ruins are inhabited by dragons, giants, or the undead.
# - The settlements are separated by wild forests, steep ascents or narrow gorges.

;map
1,[[town name]@next town name][lake]¶[town]¶[[town name]@next town name][town]

;town name
1,[town qualifier][town noun]

;town qualifier
1,Ger
1,Yver
1,Zur
1,Lor
1,Bad
1,Ror

;town noun
1,den/dd/d/
1,san
1,shen
1,sel
1,wyl
1,ttikon/rtt/tt/
1,gau

;lake
1,At the foot of the terrible mountains lies the [lake name].

;lake name
1,[lake qualifier] Lake

;lake qualifier
1,Iron[lake noun]
1,Ice[lake noun]
1,Blue[lake noun]
1,Death
3,[@next town name]

;lake noun
1,feet
1,foot
1,claw
1,bird
1,bear

;town
1,[@next town name] is a town by the [@lake name]. [town description]

;town description
1,The harbour side of [@next town name] is built on wooden poles. The calm waters of the [river name] wash away their sins into the [@lake name].
1,[@next town name] guards the entrance to the narrow [river name] valley. The steep rocks cast long shadows.
1,From the shores of [@lake name] the vinyards rise up and around [@next town name]. It is built at the foot of a sunny hill overlooking the lake.

;river name
1,White River
1,Black River
1,Cold River
1,Run River
1,Pure River
1,Green River

;character
1,[roll-attributes][[2d5] careers][name][nick name] ([[@gender] sign]) (age [@age])¶Attributes: [attributes]¶Careers: [@careers]¶Tables: [@skill tables]¶Skills: [@skills]
# ([@career history]) adds the ages and careers picked

;roll-attributes
1,[[2d6]@str][[2d6]@dex][[2d6]@end][[2d6]@int][[2d6]@edu][[2d6]@sta][[preferrence]@career][[weapon]@preferred weapon][[0d0+16]@age]

;attributes
1,Strength-[@str], Dexterity-[@dex], Endurance-[@end], Intelligence-[@int], Education-[@edu], Status-[@sta]

;name
1,[[gender] name]

;gender
1,female
1,male

;female name
1,[short female name]
5,[long female name]

;male name
1,[short male name]
5,[long male name]

;short female name
1,Ada
1,Anna
1,Berta
1,Elsa
1,Hilde
1,Inge
1,Chloe
1,Frieda
1,Gisela
1,Ulrike
1,Ute

;short male name
1,Ardo
1,Dodo
1,Else
1,Etzel
1,Gregor
1,Gundobad
1,Gyso
1,Hagen
1,Iring
1,Otto
1,Siggo
1,Swemmel
1,Werbel

;long female name
2,[name prefix][female suffix]
1,[name prefix][male suffix][a|e]

;long male name
1,[name prefix][male suffix]

;name prefix
1,Adal
1,Albe
1,Amal
1,Bald
1,Bert
1,Bote
1,Brun
1,Charde
1,Charle
1,Chari
1,Childe
1,Chilpe
1,Chlodo
1,Chrodo
1,Clot
1,Crot
1,Dago
1,Dank
1,Ecke
1,Ger
1,Gel
1,Ger
1,Gib
1,Gisel
1,Gote
1,Gunt
1,Gunde
1,Hade
1,Her
1,Hel
1,Hilde
1,Horn
1,Hu
1,Ingo
1,Krim
1,Lude
1,Man
1,Mero
1,Nant
1,Nor
1,Ort
1,Os
1,Pil
1,Ram
1,Rich
1,Rit
1,Ro
1,Rudi
1,Rum
1,Schili
1,Schru
1,Sieg
1,Sigi
1,Sind
1,Theude
1,Ul
1,Vulde
1,Walt
1,Werb
1,Wich
1,Wisi
1,Wite
1,Wolf

;female suffix
1,berga
1,burg
1,fled
1,gard
1,gund
1,hild
1,lind
1,trud

;male suffix
1,ald/[ie]a/oa/
1,bart
1,boge
1,bung
1,brand
1,chart/chch/ch/
1,dung
1,fried
1,ger
1,gang
1,gast
1,grim
1,hard/hh/h/
1,her/hh/h/
1,land
1,lieb
1,lung
1,man
1,mer
1,mund
1,mung
1,nold
1,not
1,old/oo/o/
1,rat
1,ric
1,sind
1,tan/tt/t/
1,tram
1,wart
1,wech
1,win

;nick name
1, the [[@++skills] title]

;preferrence
1,[best attribute][preferred career]

# save the best of strength/endurance into brawns
# save the best of intelligence/education into brains
# save the best of dexterity/status into smarts
;best attribute
1,[[[@str]>[@end]?[@str]:[@end]]@brawns][[[@int]>[@edu]?[@int]:[@edu]]@brains][[[@dex]>[@sta]?[@dex]:[@sta]]@smarts]

# each line does the same thing but the first one prefers warriors
# the second one mages, the last one rapscallions
;preferred career
1,[[@brawns]>=[@brains]&&[@brawns]>=[@smarts]?Warrior:[[@brains]>=[@smarts]?Mage:Rapscallion]]
1,[[@brawns]>[@brains]&&[@brawns]>[@smarts]?Warrior:[[@brains]>=[@smarts]?Mage:Rapscallion]]
1,[[@brawns]>[@brains]&&[@brawns]>[@smarts]?Warrior:[[@brains]>[@smarts]?Mage:Rapscallion]]

# There are no loops so we have to use recursion
;1 careers
1,[4 skills]
;2 careers
1,[1 careers][4 skills]
;3 careers
1,[2 careers][4 skills]
;4 careers
1,[3 careers][4 skills]
;5 careers
1,[4 careers][4 skills]
;6 careers
1,[5 careers][4 skills]
;7 careers
1,[6 careers][4 skills]
;8 careers
1,[7 careers][4 skills]
;9 careers
1,[8 careers][4 skills]
;10 careers
1,[9 careers][4 skills]

;4 skills
1,[switch career][be a knight][[@age]: [@career]@@career history][[skill]++@skills][[skill]++@skills][[skill]++@skills][[skill]++@skills][[@career]++@careers][[@skill table]++@skill tables][[4d1+[@age]]@age]

# every 4 years there's a 25% chance of switching careers
;switch career
1,[[career]@career]
3,

# if we can ride, prefer the lance
;be a knight
1,[[h.results.skills && h.results.skills.riding?Lance:[@preferred weapon]]@preferred weapon]

;skill
1,[[skill table]]

;skill table
1,[[@career] skill table]

;career
1,Warrior
1,Mage
1,Rapscallion

;Warrior skill table
1,Mercenary
1,Guard
1,Rider
1,Officer

;Mage skill table
1,Aggressive
1,Passive
1,Manipulative
1,Transgressive

;Rapscallion skill table
1,Thief
1,Thug
1,Liar
1,Murderer

;Fighting
3,[@preferred weapon]
1,[weapon]

# only learn the lance when you have riding
;weapon
2,Knife
2,Spear
1,Halberd
1,Épée
1,Bow

;Mercenary
1,Construction
1,Running
1,Tactics
1,First Aid
1,Craft
1,[Fighting]

;Guard
1,Bureaucracy
1,Discipline
1,Construction
1,Brawling
1,Brewing
1,[Fighting]

;Rider
1,Riding
1,Singing
1,Tactics
1,Spying
1,Culture
1,[Fighting]

;Officer
1,Literacy
1,Bureaucracy
1,Tactics
1,Diplomacy
1,Behavior
1,[Fighting]

;Aggressive
1,Fire
1,Air
1,Water
1,Earth
1,Storm
1,[Fighting]

;Passive
1,Healing
1,Sleep
1,Eyes
1,Doors
1,Plants
1,Brewing

;Manipulative
1,Charm
1,Singing
1,Diplomacy
1,Illusion
1,People
1,Literacy

;Transgressive
1,Shapeshift
1,Necromancy
1,Transmutation
1,Fusion
1,Animals
1,Planeshift

;Thief
1,Sneaking
1,Spying
1,Running
1,Climbing
1,Distract
1,Pickpocket

;Thug
1,[Fighting]
1,Craft
1,Running
1,First Aid
1,Tactics
1,Singing

;Liar
1,Culture
1,Behavior
1,Bureaucracy
1,Literacy
1,Oratory
1,Trading

;Murderer
1,[Fighting]
1,Brewing
1,First Aid
1,Sneaking
1,Behavior
1,Tinker

;Air title
1,Aeromancer

;Animals title
1,Whisperer

;Behavior title
1,Courtier

;Bow title
1,Hunter

;Brawling title
1,Boxer

;Brewing title
1,Brewer

;Bureaucracy title
1,Administrator

;Charm title
1,Hypnotist

;Climbing title
1,Mountaineer

;Construction title
1,Builder

;Craft title
1,Crafter

;Culture title
1,Artist

;Diplomacy title
1,Diplomat

;Discipline title
1,Task Master

;Distract title
1,Magician

;Doors title
1,Gate Mage

;Earth title
1,Geomancer

;Eyes title
1,Oculomant

;Fire title
1,Pyromancer

;First Aid title
1,Field Medic

;Fusion title
1,Vivomancer

;Halberd title
1,Halberdier

;Healing title
1,Healer

;Illusion title
1,Illusionist

;Knife title
1,Knife Fighter

;Lance title
1,Knight

;Literacy title
1,Sage

;Necromancy title
1,Necromancer

;Oratory title
1,Orator

;People title
1,Manipulator

;Pick title
1,Thief

;Planeshift title
1,Planeshifter

;Plants title
1,Botanist

;Riding title
1,Rider

;Running title
1,Runner

;Shapeshift title
1,Shapeshifter

;Singing title
1,Singer

;Sleep title
1,Dream Walker

;Sneaking title
1,Sneak

;Spear title
1,Spear Fighter

;Spying title
1,Spy

;Storm title
1,Storm Mage

;Tactics title
1,Tactician

;Tinker title
1,Tinkerer

;Trading title
1,Trader

;Transmutation title
1,Transmutater

;Water title
1,Aquamancer

;Épée title
1,Sword Fighter

</pre>
</body>
</html>
